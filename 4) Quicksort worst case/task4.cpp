#include <iostream>
#include <vector> // для работы с векторами

using namespace std;

int main() {
    int arr_size; // размер входного массива (равен размеру выходного)
    cin >> arr_size; // считываем данные о размере массива с консоли

    int input_arr[arr_size]; // входной массив последовательности выбора опорных элементов (-1 — с конца, 0 — с середины, 1 — с начала)
    for(int i=0; i<arr_size; i++) // делаем arr_size раз 
        cin >> input_arr[i]; // считываем одно число и помещаем его в input_arr (в строке консоли идёт сразу несколько, разделеных пробелом)
    
    int res[arr_size]; // массив под ответ (подразумевается, что достаточно arr_size различных элементов, например — идущих от 1 до arr_size)
    
    vector<int> indexes; // вектор с индексами для массива res, в которые модет идти запись (на каждой итерации алгоритма вектор уменьшается)
    for (int i=0; i<arr_size; i++) // добавляем столько раз, сколько у нас должно быть элемнтов
        indexes.push_back(i); // добавляем индекс в конец (будет вектор [0, ..., arr_size-1])

    int pivot; // опорный элемент (может быть -1 или 0 или 1, в зависимости от входа)
    int element; // добавляемый элемент (чтобы ухудшить Quick sort — выбираемые опорные элементы должны быть либо максимальным, либо минимальным значением в ветке алгоритма; в данном случае будут браться наибольшие)
    int pos_to_insert; // позиция для вставки
    for (int i=0; i<arr_size; i++){ // проходим по всем элементам
        pivot = input_arr[i]; // на какой позиции брать опорный элемент (-1 — с конца, 0 — с середины, 1 — с начала)
        int element = arr_size - i; // элемент, что будем добавлять (от максимального значения, равного arr_size до 1)

        if (pivot == -1){ // опорный элемент взят с конца
            pos_to_insert = indexes.back(); // берём самый правый доступный индекс для res
            indexes.pop_back(); // убираем его из доступных (pop_back удаляем самый правый элемент)
        } else if (pivot == 0){ // опорный элемент взят с середины
            pos_to_insert = indexes[(indexes.size()-1)/2]; // берём средний доступный индекс для res (indexes.size()-1, так как он на 1 больше, чем самый правый)
            indexes.erase(indexes.begin() + (indexes.size()-1)/2); // убираем его из доступных с помощью итератора
        } else if (pivot == 1){ // опорный элемент взят с начала
            pos_to_insert = indexes[0]; // берём самый левый доступный индекс для res
            indexes.erase(indexes.begin()); // убираем его из доступных с помощью итератора-начала вектора
        }
        res[pos_to_insert] = element; // записываем элемент на нужную позицию 
    }
    
    for (int i: res) // идём по всем элементам в res
        cout << i << ' '; // выводим их
    cout << endl; // переводи на новую строку
    
    return 0;  // выходим из функции с возвращением кода 0
}
