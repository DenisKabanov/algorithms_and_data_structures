#include <iostream> // для ввода/вывода
#include <string> // для работы со строчками

using namespace std;

int binarysearch(int target, int arr[], int arr_size, string &res) { // target - искомый элемент; arr - отсортированный массив, в котором будет искаться target; arr_size - размер массива arr; res - куда будет записываться промежуточный результат итерации алгоритма
    int low, high, middle; // переменные для прохода (low - левая граница, high - правая граница, middle - середина)
    low = 0; // начальная левая граница
    high = arr_size - 1; // начальная правая граница
    while (low <= high) { // пока не осмотрели массив
        middle = (low + high) / 2; // берём середину между границами
        if (target < arr[middle]){ // если target меньше рассматриваемого элемента (середины) — сдвигаем правую границу левее
            res.append(" " + to_string(arr[middle]) + "(" + to_string(middle) + ")"); // добавляем данные о промежуточной итерации в res (значение рассматриваемого элемента, его позиция)
            high = middle - 1; // смещаем правую границу  (-1 так как middle уже рассмотрен)
        }
        else if (target > arr[middle]) { // если target больше рассматриваемого элемента (середины) — сдвигаем левую границу правее
            res.append(" " + to_string(arr[middle]) + "(" + to_string(middle) + ")"); // добавляем данные о промежуточной итерации в res (значение рассматриваемого элемента, его позиция)
            low = middle + 1; // смещаем левую границу (+1 так как middle уже рассмотрен)
        }
        else { // если элемент найден
            res.append(" " + to_string(arr[middle]) + "(" + to_string(middle) + ")"); // добавляем данные о промежуточной итерации в res (значение рассматриваемого элемента, его позиция)
            return middle; // возвращаем позицию, где его нашли
        }
    }
    return -1; // если элемент не был найден
}

int main(){
    int arr_size = 0; // переменная под размер входного массива
    int target = 0; // переменная под искомый таргет

    cin >> arr_size >> target; // считывание двух чисел - размер массива и таргет с консоли

    int *input_arr = new int[arr_size]; // динамическое создание массива под входные данные
    string res = ""; // динамическое создание массива под вывод

    for(int i=0; i<arr_size; i++) // делаем arr_size раз 
        cin >> input_arr[i]; // считываем одно число и помещаем его в input_arr (в строке консоли идёт сразу несколько, разделеных пробелом)

    int binary_res = binarysearch(target, input_arr, arr_size, res); // результат бинарного поиска

    cout << "Initial array:" << endl; // вывод "заголовка"
    for(int i=0; i<arr_size; i++) // выводим поэлементно входной массив в одну строку консоли
        cout << input_arr[i] << " ";
    cout << endl << "Target element: " << target << endl; // вывод таргета
    if (binary_res != -1){ // если таргет был найден (бинарный поиск вернул не -1)
        cout << "Search history:" << res << endl; // выводим историю поиска
        cout << "Target is found at: " << binary_res << endl; // выводим позицию, где нашёлся элемент
    } else { // иначе — выводим сообщение об отсутствии таргета во входных данных
        cout << "No targets" << endl;
    }

    delete [] input_arr; // очищаем память, что была выделена под динамический массив

    return 0; // выходим из функции с возвращением кода 0
}